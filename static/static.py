import enum
import os
import pickle
import time
import sys
import numpy as np


'''
helper classes
'''

class timer():

    def start(self):
        self.start_time = time.time()

    def end(self):
        end_time = time.time()
        total_time = self.start_time - end_time
        self.hours = int(total_time / 3600)
        remaining_secs = total_time - self.hours * 3600
        self.minutes = int(remaining_secs / 60)
        self.seconds = remaining_secs - self.minutes * 60

    def show(self):
        print("Total Execution Time\n{}h : {}m : {}s".format(self.hours, self.minutes, int(self.seconds)))

class TYPE(enum.Enum):
    BENIGN = 0
    MALWARE = 1


'''
reduced features after feature selection - total 165
'''
api_features = ['PtInRect', 'GetFileSize', 'GetCurrentThreadId', 'LoadLibraryW', 'GetPropA', 'TlsSetValue', 'GetVersionExA', 'GetLocalTime', 'GetSystemTime', 'SetUnhandledExceptionFilter', 'GetExitCodeProcess', 'send', 'QueryPerformanceCounter', 'GetVersion', 'GetFileAttributesA', 'GetStdHandle', 'VariantCopy', 'GetDlgItem', 'GetACP', 'SysFreeString', 'GetModuleHandleA', 'LoadIconA', 'CharNextW', 'CoInitialize', 'SHChangeNotify', 'GetCommandLineA', 'ShowWindow', 'SetBkMode', 'FreeSid', 'VarUI4FromStr', 'GetCurrentProcessId', 'GetModuleHandleW', 'DeleteObject', 'LoadLibraryA', 'RegOpenKeyA', 'ExitThread', 'FindClose', 'GetStartupInfoA', 'GetTickCount', 'VirtualFree', 'VariantChangeTypeEx', 'RegCloseKey', 'CoTaskMemFree', 'InitializeCriticalSectionAndSpinCount', 'LocalFree', '__WSAFDIsSet', 'FindFirstFileA', 'GlobalFree', 'ReadFile', 'AreFileApisANSI', 'ExitWindowsEx', 'GetFileTitleA', 'GetModuleFileNameA', 'UnhandledExceptionFilter', 'WaitForSingleObject', 'wsprintfA', 'PostMessageA', 'RegQueryValueExA', 'VirtualAlloc', 'ShellExecuteA', 'InitCommonControls', 'SendMessageA', 'VirtualProtectEx', 'ExitProcess', 'InternetOpenA', 'InitializeCriticalSection', 'GdipFree', 'GetConsoleMode', 'RegOpenKeyExA', 'LoadLibraryExA', 'GetProcAddress', 'HeapFree', 'MessageBoxA', 'WriteFile', 'WideCharToMultiByte', 'RegEnumKeyA', 'SetStdHandle', 'RtlUnwind', 'GetLastError', 'InitCommonControlsEx', 'RaiseException', 'CreateFileW', 'CloseHandle', 'Sleep', 'ChooseColorA', 'CreateFontA', 'IsValidCodePage', 'VirtualQuery', 'LocalAlloc', 'SetWindowTextA', 'RegFlushKey', 'TlsAlloc', 'DeleteFileA', 'GetCommandLineW', 'SetLastError', 'MultiByteToWideChar', 'VariantClear', 'GetSystemMetrics', 'VerQueryValueA', 'GetSystemTimeAsFileTime', 'SetFilePointer', 'VirtualProtect', 'lstrlenA', 'SaveDC', 'ShellExecuteW', 'LeaveCriticalSection', 'TerminateProcess', 'SetEndOfFile', 'TlsFree', 'SHGetMalloc', 'FreeLibrary', 'SetErrorMode', 'GetCurrentProcess', 'DispatchMessageA', 'timeGetTime', 'GlobalAlloc', 'LoadCursorA', 'PostMessageW', 'GetWindowsDirectoryA', 'exit', 'CreateProcessA', 'CreateDirectoryA', 'FlushFileBuffers', 'CreateThread', 'WSAStartup', 'GetModuleFileNameW', 'CreateFileA', '_lopen', 'BitBlt', 'GetProcessHeap', 'DestroyWindow', 'GetErrorInfo', 'SetTimer', 'PropertySheetW', 'GetDC', 'FindWindowA']

raw_features = ['e_lfanew', 'NumberOfSections', 'MajorLinkerVersion', 'MinorLinkerVersion', 'SizeOfCode', 'SizeOfInitializedData', 'SizeOfUninitializedData', 'AddressOfEntryPoint', 'BaseOfCode', 'BaseOfData', 'MajorOperatingSystemVersion', 'MinorOperatingSystemVersion', 'MajorImageVersion', 'MinorImageVersion', 'MajorSubsystemVersion', 'CheckSum', 'Subsystem', 'SizeOfStackReserve', 'SizeOfStackCommit', 'SizeOfHeapReserve', 'ImageBase', 'SectionAlignment', 'FileAlignment', 'SizeOfImage', 'SizeOfHeaders']
derived_features = ['StringFileInfo', 'Characteristics', 'DllCharacteristics']
aux_derived = ['[StringFileInfo]', '[IMAGE_FILE_HEADER]', '[IMAGE_OPTIONAL_HEADER]']
str_features = raw_features + derived_features

feature_names = str_features + api_features + ['IsPacked']


'''
@function
    usage helper function
'''
def display_help(category=None):
    string = "Incorrect Usage: "
    if category == None:
        string = "Usage:\tpython static.py [OPTION]... [FILE]...\nTag given data-set with labels M/B (Malware/Benign)\n\n" \
                 "--help  display this help info\n\nOptions:\n\t" \
                 "data dump\n\t\t-d  <path to directory containing train data>  <path to dump the training data as .csv file>\n\t" \
                 "validate\n\t\t-v  <path to .dat file>\n\t" \
                 "train\n\t\t-t  <path to .dat file>  <path to dump model as .model file\n\t" \
                 "predict\n\t\t-p  <path to directory containing test data>  <path to .model file>\n\n" \
                 "Example:\n\tpython static.py -p /home/data/test/static /home/model/static.model\n\n" \
                 "Note:\n\tdata dump - creates a .dat file in same directory as .csv file with same name\n\tpredict   - creates static.csv containing all samples with their respective tags (M/B)\n\n" \
                 "Warning: Please use only one option at a time to avoid any unexpected behavior.\n"
    elif category == "data":
        string += "Missing data path(s)\nPlease use the below format to execute the script\n\nUsage: python static.py [OPTION]... [FILE]...\n\n" \
                  "data dump: (also creates a .dat file in same directory as .csv file with same name)\n\t\t-d  <path to directory containing train data>  <path to dump the training data as csv>\n" \
                  "Example:\n\tpython static.py -d /home/data/train/static /home/data/train/static.csv\n"
    elif category == "validate":
        string += "Missing .dat file\nPlease use the below format to execute the script\n\nUsage: python static.py [OPTION]... [FILE]...\n\n" \
                  "validate: \n\t\t-v  <path to .dat file>\n" \
                  "Example:\n\tpython static.py -v /home/data/train/static.dat\n"
    elif category == "train":
        string += "Missing data path(s)\nPlease use the below format to execute the script\n\nUsage: python static.py [OPTION]... [FILE]...\n\n" \
                  "train:\n\t\t-t  <path to .dat file>  <path to dump model as .model file>\n" \
                  "Example:\n\tpython static.py -t /home/data/train/static.dat /home/data/train/static.model\n"
    elif category == "predict":
        string += "Missing data path(s)\nPlease use the below format to execute the script\n\nUsage: python static.py [OPTION]... [FILE]...\n\n" \
                 "predict:\n\t\t-p  <path to directory containing test data>  <path to .model file>\n\n" \
                 "Example:\n\tpython static.py -p /home/data/test/static /home/model/static.model\n"
    print(string)

'''
main functions
'''

'''
@input
    filedir_path    - absolute path to the directory containing data files related to the sample
@output
    True/ False
@function
    checks whether the given sample is packed or non-packed based on certain heuristics
'''
def isPacked(filedir_path):
    with open(os.path.join(filedir_path, "Structure_Info.txt"), 'rb') as fh:
        ispacked = True
        lines = fh.readlines()
        for index, line in enumerate(lines):
            line = line.decode('utf8', 'ignore').split()
            if ('.text' in line or 'CODE' in line):
                ispacked = False
                # mark this line no
                marked_line = index
                break
        # even with .text section, it might still be packed
        if not ispacked:
            # vSize/rSize mentioned 4/6 lines below
            vSize_line = lines[marked_line + 4].decode('utf8', 'ignore').split()
            rSize_line = lines[marked_line + 6].decode('utf8', 'ignore').split()
            # read hex string to integer - significant size difference between raw size and virtual size
            if (int(rSize_line[3], 16) < int(vSize_line[3], 16) / 16):
                ispacked = True
        return ispacked


'''
@input
    filedir_path    - absolute path to the directory containing data files related to the sample
@output
    list of APIs in given sample
@function
    extracts all relavant APIs feature information from the data files related to the sample and builds a list of APIs
'''
def find_apis(filedir_path):
    api_list = []
    # .../Malware/Trojan/0aeb1...
    with open(os.path.join(filedir_path, "Structure_Info.txt"), 'rb') as fh:
        lines = fh.readlines()
        for line in lines:
            line = line.decode('utf8', 'ignore')
            try:
                api = line.split()[0].split('.')
                if 'dll' == api[1].lower():
                    api_list.append(api[2])
            except:
                pass
        return api_list


'''
@input
    filedir_path    - absolute path to the directory containing data files related to the sample
@output
    dictionary of features
@function
    extracts all relavant API feature information from the data files related to the sample and builds a dictionary
'''
def get_api_features(filedir_path):
    features_dict = dict.fromkeys(api_features, 0)
    api_list = find_apis(filedir_path)
    for api in api_list:
        if features_dict.get(api, -1) != -1:
            features_dict[api] += 1
    return features_dict


'''
@input
    filedir_path    - absolute path to the directory containing data files related to the sample
@output
    dictionary of features
@function
    extracts all relavant structural feature information from the data files related to the sample and builds a dictionary
'''
def get_str_features(filedir_path):
    raw_features_dict = dict.fromkeys(raw_features, 0)
    derived_features_dict = dict.fromkeys(derived_features, 0)
    # parse file to get the third field
    with open(os.path.join(filedir_path, "Structure_Info.txt"), 'rb') as fh:
        lines = fh.readlines()
        for index, line in enumerate(lines):
            line = line.decode('utf8', 'ignore').split()
            # process it, if is in list of features
            try:
                field = line[2][:-1]
                if field in raw_features:
                    # convert to integer & store
                    value = int(line[3], 16)
                    raw_features_dict[field] = value
            except:
                try:
                    if line[0] == aux_derived[0]:
                        derived_features_dict['StringFileInfo'] = 1
                    elif line[0] == aux_derived[1]:
                        value = int(lines[index + 7].split()[3], 16)
                        derived_features_dict['Characteristics'] = value
                        # print("Found: ", derived_features_dict['Characteristics'])
                    elif line[0] == aux_derived[2]:
                        value = int(lines[index + 24].split()[3], 16)
                        derived_features_dict['DllCharacteristics'] = value
                except:
                    continue
            continue
        return { **raw_features_dict, **derived_features_dict }


'''
@input
    filedir_path    - absolute path to the directory containing data files related to the sample
@output
    dictionary of features
@function
    extracts all relavant feature information from the data files related to the sample and builds a dictionary
'''
def extract_features(filedir_path):
    str_features_dict = get_str_features(filedir_path)
    api_features_dict = get_api_features(filedir_path)
    return { **str_features_dict, **api_features_dict }


def main():
    arg_list = sys.argv

    try:
        predict_model = arg_list.index('-p')
    except ValueError:
        predict_model = 0
    try:
        help = arg_list.index('--help')
    except ValueError:
        help = 0

    if help or not (predict_model):
        display_help()

    # predict based on data.model
    if predict_model:
        try:
            path_to_data_dir = arg_list[predict_model + 1]
            path_to_model = arg_list[predict_model + 2]
        except:
            display_help("predict")
            exit(1)
        with open(path_to_model, 'rb') as f:
            model = pickle.load(f)
        aux_features_dict = {'IsPacked': 0}
        print("Processing Files...")
        file_count = sum(len(files) for _, _, files in os.walk(path_to_data_dir)) / 3
        steps = int((file_count * 10) / 100)
        count = 0
        percentage = 10
        with open("static.csv", 'w') as fh:
            fh.write("File_Hash,Predicted Label")
            file_name_list = []
            feature_vec_list = []
            for file_dir in os.listdir(path_to_data_dir):
                count += 1
                if count % steps == 0 and percentage < 100:
                    print("...%d%%" % (percentage), end='', flush=True)
                    percentage += 10
                # .../Malware/Trojan/0aeb1...
                abs_file_dir_path = os.path.join(path_to_data_dir, file_dir)
                if isPacked(abs_file_dir_path):
                    aux_features_dict['IsPacked'] = 1
                else:
                    aux_features_dict['IsPacked'] = 0
                feature_dict = {**extract_features(abs_file_dir_path), **aux_features_dict}
                feature_vec = []
                for feature in feature_names:
                    feature_vec.append(feature_dict[feature])
                feature_vec_list.append(feature_vec)
                file_name_list.append(file_dir)
            print("...100%\nCompleted\n")
            print("Dumping results to static.csv...")
            test_data = np.array(feature_vec_list, dtype=np.int)
            y = model.predict(test_data)
            label_list = list(map(lambda i: 'M' if i == 1 else 'B', y))
            for item in zip(file_name_list, label_list):
                fh.write("\n" + item[0] + "," + item[1])
            print("Done\n")


if __name__ == '__main__':
    main_timer = timer()
    main_timer.start()
    main()
    main_timer.end()
    main_timer.show()
